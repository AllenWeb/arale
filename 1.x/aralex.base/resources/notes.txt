//这个是基本组建的基类。但是这个目前不一定能考虑完全,所以只能先把一部分事情做了.
//下面我们将把我们需要的功能给描述出来
//1.需要提供继承的功能,而且可能还需要多重继承的功能。因为我们的子类可能具有多个特点
//2.一个widget完整的生命周期。我们基本的想法就是一个widget应该从无到有,会有一个可描述的过程。
//3.需要提供必须覆盖的接口,或者是需要提供默认实现的功能
//4.事件的绑定.目前是模拟dojo方式好呢?在模版上标明我们需要提供的事件呢？还是说我们限定住我们所有绑定的都是针对dom元素
//然后同过delegata来让用户自己提供实现.我们拿两个组建来说明一下
//(1).apop.这个组建我们需要的事件有一下情况.onmouseover,需要持续显示,当mouseout,组件隐藏。那我们如果有其情况呢？好像目前没有了.
//但是具体的隐藏规则可能有变化,因为有的apop可能不需要我们绑定这个事件。所以需要有一种机制来把他给剥离出去。比如我们可以需要包括一个组件。这个组件里面封装了
//mouseover和mouseout事件。但是也可以是一类,我们可以定义一些列事件组件来进行分离。
//(2).还有就是我们需要定义一些显示隐藏方法。提供给使用此组建的对象。
//(3).还有就是我们需要对组件进行设置比如我们显示的位置:但是对一个组建进行位置设定。可以有下列方式,直接提供坐标,或者设置class.
//(4).还有一个就是我们有些组件是需要在文档中占有一定位置的。我们需要在我们初始化的时候提供一个参数,然后我们需要把组件的内容给替换到里面,如果组件是没有位置的话
//那它可能就需要我们来传递它的parent,然后我们把它绝对定位,然后给插入到他的parent,如果没有设置parent,那我们就给他设置到body里面
//(5).还有就是事件绑定的机制,我们需要给用户提供一些接口,但是突然发现好像有两种情况.
//(a)第一个就是我们组件本身会发生一些事件,比若我们上面提到的mouseover,mouseout
//这些事件。这些事件本身可能根据不同的情况会有些变化,那么是否需要提供默认行为呢？还是同过继承给用户两种不同的选择呢？
//(b)第二就是当用户某个事件触发的时候会调用我们组件的某个方法比如校验那里,当一个input组件产生错误的时候,则会调用我们组件的显示这个方法。然后当用户满足一定条件
//的情况下则会隐藏.但是如何让用户进行绑定呢？dojo的做法是下面这样
//var widget = new Widget();
//widget.connect(obj,"fn",function(){
//	this.show();
//})   
//当我们在fn执行后,就会触发我们widget的show这个方法。这样就给用户感觉上好一点.其实用户也完全可以这样做
//arale.connect(obj,"fn",widget,function(){
	//this.show();
//})
//这样做不好的地方就是可能当我们的widget进行destory的时候,我们无法进行把原来已经绑定和widget相关的事件绑定给注销掉,这样我们通过
//在内部的事件绑定机制,就可以当我们destory的时候，自己手动的去处理了。

//5.模版的渲染和处理.这也是比较重要的一部分,这个的情况主要是用于以下情况,我们在页面中有一些列相同外观的pop,但是我们只是内容不同,这样我们就可以使用模版,只是
//当数据过来的时候我们进行替换。这个基本上也有以下过程。我们可能针对不同组件可能会有不同的区分吧,针对与apop,有其特殊行,他可以明确的分为外在状态和内在状态,本质的东西是
//不变的,而其外在状态就是他的位置和内容是不停在变化的,我们全局实际上就可以有一个这样的对象.具体的做法突然想到了以下2种
//(1).我们这个widget在全局只是一个对像,他自己的dom对象并不存在与文档流中(在上面可能提到了,一定会给组件在文档刘中保存一个位置,但是发现这种情况可能不需要).
//只是我们需要用户提供一个参数,就是内容,然后我们把我们渲染好的html给用户,用户拿到后把html片段填充到需要的地方,这个比较适合日历,因为我们这个还牵扯到组件的事件。
//(2).就是每次我们只是需要把组件需要的内容和位置信息提供给组件,然后组件自己进行调整即可。这样对于apop这种简单的组件绑定事件就不用重复绑定了,因为我们组件全局只是
//用了一个,不用重复绑定了。
//(3).但是对于比较复杂的呢？就是说每次我们模版里面的内容变化比较大(这种情况好像很少见,那我自己先想一个吧),比若我们现在在做ajaxTable,然后在table中
//其中有一行的一个字段是name吧,然后到用户把鼠标移动到name这个span上的时候,可能会弹出一个apop,而且我们每次翻页的时候,这些元素实际都是在变的,所以我们
//如果我们直接绑定name这个span的话,那我们就会重复绑定大量事件,所以我们现在的做法是我们绑定的是整个widget这个dom元素的悬停事件。看个例子

//var widget = new Widget();
//widget.addEvent("onmouseover",function(e){
	/**
	if(e.target.tagName == 'span' && $Node(this.node).hasClass('name')){
		//在这里进行事件处理,但是这个事件好像有点问题,就是mouseout事件如何让span捕获到,看下面的例子,是可以捕获到的
	}
	*/
//})
/**
var div =$Node('div');
console.log(div.style);
div.attr('id',"div1");
div.setStyle({
    border:'1px solid red',
    width:'200px',
    height:'200px'
});
div.inject(document.body);
$E.connect(document.body,"onmouseover",function(e){
    if(e.target.tagName.toLowerCase() == 'div' && e.target.id == 'div1'){
        console.log("over");
    }

});
$E.connect(document.body,"onmouseout",function(e){
      if(e.target.tagName.toLowerCase() == 'div' && e.target.id == 'div1'){
        console.log("out");
    }
})
**/
//(4).不过上面还让我们引入了一个新的问题,就是我们原来的模版替换内容的问题,还有就是我们如何获取局部的模版,现在每次模版渲染都是整体的.目前还是无法支持局部渲染,因为我们
//无法从整体模版中抽出一部分。到时候想想办法看看能不能同过一种手段进行分割,同过正则应该是可以的。

//(5).现在我们就可以来概述整个过程了.中间可能会有很多的分支,因为可能有不同情况,以后每种分支我们就会通过不同的参数来进行分支选择
//a.首先我们需要初始化模版,这时候需要传递的参数可能有
//	1.id(我们需要把模版的内容替换到这个id元素的下面),dom(有可能我们这个组件需要自己独立的显示出来,我们需要给他指定父亲元素)
//	,如果没有参数的话原本想给他放到body下面,但是可能会有我们这个widget就是需要提供html片段的,根据不同的数据()。
//	2.我们可能是已经获取数据了,才会初始化模版,但是好多情况下初始化模版是没有数据的,那么我们就需要延迟进行模版渲染了。但是有这么一个情况,就是模版本身是有一个外观的
//	外观是否可以先生成出来,只是数据可能会延迟才出来。那们我们就需要用到<script type="text/html"></script>这个东东了。我们可以把我们需要进行数据转换
//  的内容放到这个里面,由于type浏览器不认识,所以不影响啥,这样我们就可以在内部指定一个区域,用来渲染不同的内容。看下面的例子.
//然后只是在有数据的时候,把我们的想应的区域进行填充而已,但是多个都需要模版填充的内容是不能用模版前套的。具体的填充规则也是需要自己去实现的
/**
<div id="ajaxtable">
	<script type="text/html" id="tmpl1">
		<% =name %
	</script>
	<script type="text/html" id="tmpl2">
		<% =name %
	</script>
	<div id="content1"></div>
	<div id="content2"></div>
</div>
**/
//这样我们就可以先根据是否有数据来进行是否执行模版绑定的处理,但是具体的处理规则是需要根据不同的widget来进行不同的初始化的
//然后我们下一步就是进行事件绑定,但是自己内部的事件绑定需要自己去覆盖bind(随便想的名字)这个方法,在这个方法中需要把我们dom需要自我绑定的事件处理好
//当我们把事件绑定好,然后就开始执行render方法了。根据用户提供的参数来决定把我们的dom填充到那个位置

//b.然后我们的widget就可以返回给用户了,然后用户可以在绑定相应自己的事件,来触发我们widget某些事件而已。

//c.下一步考虑的就是我们Widget需要给具体的子Widget提供那些接口,从而来保证我们widget的完整性,还有就是我们的widget需要提供那些接口。来让用户更方便的和
//我们的widget来进行交互。

//好了就写到这里吧。今天有点走神。所以时间有点晚了

//TODO. Ｃlass创建的机制修改,
//TODO Widget生命周期模版方法的实现,还有基本接口的定义,按照上面的分析应该没有什么太大问题了
//TODO Apop的实现,现在发现apop也有很多版本的,所以需要考虑的更周全





//现在dom绑定可能有点问题,就是我们模版的外壳到底怎么处理.目前最好的应该是在我们的模版中包含了整个外观元素.这样我们就方便控制,现在的问题是